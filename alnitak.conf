# alnitak.conf
# ============
#
# This configuration file sets 'targets' for the alnitak program. These
# 'targets' are Let's Encrypt domain folders (typically, those directories
# found in /etc/letsencrypt/{live,archive}), together with a
# 'tlsa specification', in an ini-style format. Such targets should be
# created for all domains for which you want the alnitak program to manage
# TLSA records.
#
# A target looks like:
#
#    [ LE_DOMAIN ]
#    tlsa = PARAM PORT PROTOCOL DNS_DOMAIN
#
# When a certificate in /etc/letsencrypt/archive/LE_DOMAIN is renewed, alnitak
# will attempt to generate a new TLSA record. For example, for a target:
#
#   [example.com]
#    tlsa = 311 25 tcp mail.example.com
#
# alnitak will attempt to publish a TLSA record:
#
#    _25._tcp.mail.example.com  TLSA 3 1 1  <certificate_data>...
#
# when the certificates in /etc/letsencrypt/archive/example.com/ are renewed.
#
# Multiple tlsa specifications may be given, in which case multiple TLSA
# records will be created when the LE_DOMAIN certificate is renewed.
#
# More detailed information of the fields of a target specification are as
# follows:
#
#    LE_DOMAIN
#
#       This should be the name of the folder within which your Let's Encrypt
#       certificate files are located. This will NOT necessarily be the domain
#       of the service being run since Let's Encrypt allows the generation of
#       multi-domain certificates. In that case, you might be running your
#       service on the subdomain 'service.example.com', but the certificates
#       themselves are located in /etc/letsencrypt/archive/example.com/; what
#       we want for LE_DOMAIN in this case is 'example.com' and NOT
#       'service.example.com'.
#
#    PARAM
#
#      The first field of the 'tlsa specification' should be the parameters
#      required for the TLSA record (concatenated together). The alnitak
#      program will extract the certificate data corresponding to the chosen
#      parameters for you (so you don't need to mess about with certificates
#      or openssl/libressl yourself); it will then either try to publish a
#      TLSA record for you, or else help you to do so.
#
#      TLSA parameters are formed of three fields: a usage field (we only
#      support DANE-TA[2] and DANE-EE[3]), a selector field and a matching
#      type field:
#
#         PARAM:   <usage><selector><matching>
#
#         where:
#            usage:      2|3
#            selector:   0|1
#            matching   0|1|2
#
#    PORT
#
#      The second field of the 'tlsa specification' is the port number on
#      which your service is running. Typical values are: 25 for SMTP,
#      443 for HTTPS, etc.
#
#      The value given should be an integer: 0 < PORT < 65536.
#
#    PROTOCOL
#
#      The third field is optional, and should be the protocol of the TLSA
#      record. If you omit this field, the default protocol 'tcp' will be
#      used, which is usually fine.
#
#    DNS_DOMAIN
#
#      The last field is optional, and should be the domain name of the
#      service for which the SSL certificates have been renewed. Normally
#      this will match LE_DOMAIN, but if your service is running on an
#      alternate name in a multi-domain certificate, your Let's Encrypt
#      certificates will NOT be located inside of folders named after your
#      service domain name, but instead will be under the primary domain name
#      of your multi-domain certificate. See also the LE_DOMAIN description,
#      above.
#
#      If this field is omitted, then its value will be set to the LE_DOMAIN
#      field value. If your service is not running on a multi-domain
#      certificate, this will be fine; otherwise, you MUST give this field
#      explicitly. Note that if you do decide to explicitly set this field,
#      you do not need to also specify a PROTOCOL field: the following tlsa
#      specification will work as expected:
#
#         tlsa = 311 25 mail.example.com  # <-- PROTOCOL will be 'tcp'
#
#
#
# In order to help manage TLSA records, in addition to at least one target
# specification, you will also need to set an 'API scheme'. Properly managing
# TLSA records requires a programmatic way to amend DNS zones. As such,
# alnitak needs to know how to do this. An API scheme is set as follows:
#
#    api = SCHEME OPTIONS...
#
# and can either be placed before any targets (in which case it will apply to
# all targets) and/or can be placed within a target specificiation (in which
# case it will apply only to that target).
#
# The following API schemes are supported:
#
#    SCHEME
#
#       - cloudflare4
#
#          If you are using Cloudflare to manage your DNS settings, then
#          alnitak can manage interacting with Cloudflare on your behalf,
#          using the Cloudflare API v4 interface. What this means is that
#          alnitak will manage creating and deleting TLSA records (for the
#          targets given). The alnitak program requires your Cloudflare login
#          name and your DNS zone identifier and key in order to do this.
#          These can either be given directly:
#
#             api = cloudflare4 email:me@mail.com zone:abc... key:123...
#
#          Or be placed in a separate file:
#
#             api = cloudflare4 /home/me/cloudflare.txt
#
#          where the contents of the separate file should be:
#
#             # /home/me/cloudflare.txt
#             # comments are allowed in here
#             email = me@email.com
#             zone = abc...   # zone
#            # key:
#             key = 123...
#
#          You should give the full path to this separate file, avoiding
#          shell shortcuts (i.e., '/home/X' instead of '~' or '~X' etc.).
#
#         BE AWARE: your cloudflare login details are sensitive and should
#         not be freely readable.
#
#         If you wish to keep your login details in this configuration file
#         directly, then you ought to make this file owner-readable only
#         (mode 600) and owned by root. We recommend keeping your login
#         details in a separate file that is root-owned and only readable to
#         root. Keeping your login details in this configuration file
#         directly may increase the likelihood of their release since this
#         file might see much more editing and hence risk an accidental
#         loosening of permissions: keep your login details in a restricted
#         file out of the way.
#
#       - binary
#
#         If no other API scheme is applicable, you can specify an external
#         program to manage your DNS zone as:
#
#            api = binary /full/path/to/program --with "some flags"
#
#         alnitak will then call 'program --with "some flags"' when it needs
#         to create or delete DNS records. The external program must be able
#         to do both of these operations, distinguished by the environment
#         parameter 'TLSA_OPERATION'. In detail, the program must do the
#         following:
#
#         create records:
#            The environment parameter 'TLSA_OPERATION' will be set to the
#            value 'publish'.
#
#            The program should exit with code:
#
#               0 - if the TLSA record was published
#               1 - if the TLSA record was already up
#               n - if an error occurred in publishing the record
#
#            Alnitak will handle what to do if any of these scenarios is
#            encountered. Note that you need to distinguish between a new
#            record that was published and one that was already up, as
#            otherwise it will be deleted by alnitak at some point: if you
#            return '1' if the record was already live, alnitak will not do
#            any further processing of that record. This is what you want
#            to happen if you publish a DANE-TA(2) record, since these
#            records do not always change when a certificate is renewed.
#
#         delete records:
#            The environment parameter 'TLSA_OPERATION' will be set to the
#            value 'delete'. Additionally, the environment parameter
#            'TLSA_LIVE_HASH' will be set to the certificate data for the
#            new TLSA record (which will already have been published). This
#            is provided so that you do not delete the old TLSA record
#            without first ensuring that the new TLSA record is up, which
#            you really ought to do.
#
#            The program should exit with code:
#
#               0 - if the old record was deleted successfully
#               1 - if the new record was not up yet, for whatever reason
#               n - if an error occurred whilst trying to delete the old
#                  record
#
#
#         Whether creating or deleting DNS records, the environment will
#         also have set the parameters:
#
#            PATH
#               Will be set to:
#               /bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin
#
#            IFS
#               Will be set to: " \t\n"
#
#            TLSA_USAGE
#               Will be set to the TLSA parameter usage field. The value
#               will be either "2" or "3".
#
#            TLSA_SELECTOR
#               Will be set to the TLSA parameter selector field. The
#               value will be either "0" or "1".
#               
#            TLSA_MATCHING
#               Will be set to the TLSA parameter matching type field. The
#               value will be either "0", "1" or "2".
#
#            TLSA_PARAM
#               Will be set to the full (concatenated) TLSA parameter
#               formed of the usage, selector and matching type fields. An
#               example value might be "311" or "201" etc.
#
#            TLSA_PORT
#               Will be set to the TLSA record port. Example values might
#               be "25" (for SMTP) or "443" (for HTTPS).
#
#            TLSA_PROTOCOL
#               Will be set to the TLSA record protocol. Usually this will
#               be "tcp".
#
#            TLSA_DOMAIN
#               Will be set to the TLSA record domain. This will be the
#               'DNS_DOMAIN' field that was described in the target
#               description above.
#
#            TLSA_HASH
#               Will be set to the certificate data (corresponding to the
#               TLSA parameter given) that is to be published/deleted.
#               Usually this will be a SHA2-256 hash (corresponding to a
#               matching type of '1'), but can also be a SHA2-512 hash
#               (matching type of '2') or the raw certificate data itself
#               (matching type '0'). The value will always be a hex string
#               of lower-case characters.
#
#         Note that the external command is run as root, and also that the
#         process will be killed if it has not exited after 300 seconds,
#         which should be more than enough time. If the process is killed by
#         the timeout limit it will always be treated as an error, no matter
#         what the program managed to do before it was killed.
#



### Setup ###
#
# Set the directory where the dane symlinks will be created. You can set this
# to any directory, but it should be a folder not known to any other program
# in order to ensure nothing else tampers with the files that alnitak creates.
# If any parent directory does not exist, alnitak will create them. Alnitak
# will also set the permissions of the final directory to ownership root:root
# and mode 0700 in order to not leak the private key pem files, even if the
# directory given already exists.
#dane_directory = /etc/alnitak/dane

# Set the directory where the Let's Encrypt 'live' and 'archive' folders are
# located. This is usually /etc/letsencrypt, so you don't normally need to set
# this to any other value unless you have a customized or unique setup
#letsencrypt_directory = /etc/letsencrypt



### API Scheme ###
#
# You should uncomment one of the following API Schemes.
#
## Cloudflare API v4 (login file)
#api = cloudflare4 /FULL_PATH/LOGIN_FILE
#
## Cloudflare API v4 (login details) [NOTE: This file should be root:root 0600]
#api = cloudflare4 email:EMAIL zone:ZONE key:KEY
#
## External Program (run as root)
#api = binary /FULL_PATH/EXTERNAL_PROGRAM [ARGS...]
## External Program (run as user 'nobody')
#api = binary uid:nobody /FULL_PATH/EXTERNAL_PROGRAM [ARGS...]


### MAIL ###
#
# Set _LE_DOMAIN_ to an appropriate value. If you are using a mult-domain
# certificate, then use the second target and set _DNS_DOMAIN_ to an
# appropriate value.
#
#[ _LE_DOMAIN_ ]
#tlsa = 311 25
#tlsa = 201 25
#
#[ _LE_DOMAIN_ ]
#tlsa = 311 25 _DNS_DOMAIN_
#tlsa = 201 25 _DNS_DOMAIN_



### WWW ###
#
# Set _LE_DOMAIN_ to an appropriate value. If you are using a mult-domain
# certificate, then use the second target and set _DNS_DOMAIN_ to an
# appropriate value.
#
#[ _LE_DOMAIN_ ]
#tlsa = 311 443
#tlsa = 201 443
#
#[ _LE_DOMAIN_ ]
#tlsa = 311 443 _DNS_DOMAIN_
#tlsa = 201 443 _DNS_DOMAIN_

